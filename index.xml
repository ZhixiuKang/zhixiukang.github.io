<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>修的个人网站</title>
    <link>https://zhixiukang.com/</link>
    <description>Recent content on 修的个人网站</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 24 May 2020 22:21:33 -0800</lastBuildDate><atom:link href="https://zhixiukang.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>股市长期回报率的影响因素</title>
      <link>https://zhixiukang.com/explore/stock-market-long-term-return-on-investment-and-its-influence-factors/</link>
      <pubDate>Sun, 24 May 2020 22:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/explore/stock-market-long-term-return-on-investment-and-its-influence-factors/</guid>
      <description>在谈这个问题之前，先科普一下股息率、盈利增长率和市盈率。
股息率  Dividend yield
  每股股息 除以 每股股价 就是股息率 举个例子:  现金股息为 1元，股价20元，则股息率为5%；若来年配息仍为 1元，股价已至25元，则股息率降为4%。
盈利增长率  这个很简单，年盈利增长率就是当年利润减去上一年的利润然后除以上一年利润 举个例子:  某企业当年利润5亿，上一年利润4亿，那么该企业的年盈利增长率就是(5-4)/4=25%
市盈率  Price-to-Earning Ratio, P/E或PER
  指每股市价除以每股盈余   每股盈余(Earnings Per Share, EPS)
  每股盈余的计算方法，一般是该企业在过去一年的净利润，除以总发行已售出股份净值。
  举个例子:  假设某股票的市价为24元，而过去一年的每股盈余为3元，那么市盈率就是每股市价除以每股盈余为24/3=8。该股票就被视为有8倍的市盈率。
 不考虑通货膨胀等因素，回本期为8年，折合平均年回报率为12.5%
  比较不同行业、不同国家、不同时段的市盈率是不大可靠的，比较同类股票的市盈率才比较有实用价值。
  理论上，股票的市盈率愈低，表示该股票的投资风险越小，愈值得投资。（股价低，盈余高)
 市场长期回报率 Jack Bogle在《共同基金常识》中总结了决定股市长期回报率的三个变量，分别就是:
 初始投资时刻的股息率 随后的盈利增长率 在投资期内市盈率的变化   通过分析这三个因素对总回报率的贡献，我们能够理性地预测未来的回报率。
 初始的股息率是一个已知的量。相对而言，在一个相当窄的参数范围内，盈利增长率通常是可预测的。同时，市盈率的变化已被证明具有高度投机性，总回报率就是这三个因素之和。
例如，假定初始股息率为3%，在随后的10年内，预测盈利增长率为每年7%，则回报率将为10%。
如果市盈率P/E从期初的15倍，预期变为期末的18倍，这将使总回报率增加两个百分点，股票回报率将达到12%。
 现实回报率 = 初始股息率 + 年平均盈利增长率 ＋ 年平均市盈率变动   在对10年期权股市名义回报率(1927年至2009年中)的历史数据分析中，历史数据和这一推测吻合的很好。比如，从1960年一月到1969年12月，初始股息率3.</description>
    </item>
    
    <item>
      <title>React: Hooks原理解析</title>
      <link>https://zhixiukang.com/posts/react-hooks-principles/</link>
      <pubDate>Mon, 11 May 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/react-hooks-principles/</guid>
      <description>最简单的 useState 实现 useState 原理 import React from &amp;quot;react&amp;quot;; import ReactDOM from &amp;quot;react-dom&amp;quot;; const rootElement = document.getElementById(&amp;quot;root&amp;quot;); function App() { const [n, setN] = React.useState(0); return ( &amp;lt;div className=&amp;quot;App&amp;quot;&amp;gt; &amp;lt;p&amp;gt;{n}&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;button onClick={() =&amp;gt; setN(n + 1)}&amp;gt;+1&amp;lt;/button&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); } ReactDOM.render(&amp;lt;App /&amp;gt;, rootElement);   自己试试 - CodeSandbox
  你以为的n一开始是0，然后通过setN改变n，这是一般人看这个代码脑补的过程，但是，这个过程是错误的。
 这里是实际的情况:
脑补之后 问自己几个问题  执行setN的时候会发生什么？n会变吗？App() 会重新执行吗？   要重新渲染UI，因为把n变了。n不会变，而是说我要把n变了，这个时候n是不变的，也就是说setN并不会改变n。App() 当然会重新执行
  如果 App() 会重新执行，那么 useState(0) 的时候，n每次的值会有不同吗？   通过console.</description>
    </item>
    
    <item>
      <title>虚拟 DOM 和 DOM diff</title>
      <link>https://zhixiukang.com/posts/virtual-dom-and-dom-diff/</link>
      <pubDate>Sun, 03 May 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/virtual-dom-and-dom-diff/</guid>
      <description>虚拟 DOM  与「真实 DOM」对应
 关于 DOM 的谣言 DOM 操作慢？虚拟 DOM 快  这句话类似于：刘翔矮（对比于姚明） DOM 操作慢是对比于 JS 原生 API，如数组操作 任何基于 DOM 的库（Vue/React）都不可能在操作 DOM 时比 DOM 快  为什么网上有这样的谣言？  因为在某些情况下，虚拟 DOM 快  哪些情况请继续看
   虚拟 DOM 是什么  是一个能代表 DOM 树的对象，通常含有标签名、标签上的属性、事件监听和子元素们，以及其他属性  虚拟 DOM 的优点 减少 DOM 操作  虚拟 DOM 可以将多次操作合并为一次操作，比如你添加 1000 个节点，却是一个接一个操作的（减少频率） 虚拟 DOM 借助 DOM diff 可以把多余的操作省掉，比如你添加 1000 个节点，其实只有 10 个是新增的（减少范围）  跨平台  虚拟 DOM 不仅可以变成 DOM，还可以变成小程序、iOS 应用、安卓应用，因为虚拟 DOM 本质上只是一个 JS 对象  虚拟 DOM 长什么样子  React  const vNode = { key: null, props: { children: [ // 子元素们 { type: &#39;span&#39;, .</description>
    </item>
    
    <item>
      <title>Scrum框架</title>
      <link>https://zhixiukang.com/posts/scrum-framework/</link>
      <pubDate>Sun, 26 Apr 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/scrum-framework/</guid>
      <description>最近发现很多地方都用 Scrum 框架来管理软件开发项目，那么什么是 Scrum 框架呢，它有什么用并且如何使用呢？下面让我一一讲讲自己的理解。
两张好图 结合图说说 在做软件开发的时候，一开始总是会有一些想法，我们把这些想法统一放到一个地方，也就是product backlog(代办列表)。这里面有一个人对这里面的所有条目负责，这个人就叫做product owner。有了这些条目和产品负责人后，我们可以进入到我们的迭代，也就是我们的sprint，注意，在进入sprint之前，我们的product backlog里还是会有准备好的至少一个sprint的内容。
在进入sprint后呢，第一个事情，就是开一个sprint planning，在这个计划会中有两件重要的内容，一个就是我们在这个sprint里要做什么，一个就是这些条目如何实现。我们会从product backlog中选择一些条目放进sprint planning，sprint planning结束后，我们会有两个输出: 一个输出是这个 sprint的目标(sprint goal)，一个就是白板(sprint backlog)。一般的白板会包括TO DO, DOING, DONE几个部分。
有了这个sprint backlog后，开发团队每天会对着这个这个白板进行daily scrum，在daily scrum上，每个成员要回答三个问题，即昨天我做了什么帮助团队实现sprint目标，今天我准备做什么帮助团队实现sprint目标，还有在这中间有没有遇到什么问题或者障碍。
随着sprint一天一天的进行，团队最后有一个产出物，叫做increment(产品增量)。产品增量的含义是，我们从 product backlog中取出了几个条目，这几个条目已经被完全实现了，产生了最后的产品增量。
有了产品增量后，我们会在sprint review中，去对交付内容(产品增量)进行反馈，sprint review主要是对产品进行反馈。sprint review结束后，我们还有一个sprint retrospective，整个团队会回顾整个sprint哪些地方做的好或不好，主要是团队对自己的工作流程工作方法进行反馈。
这里面注意，进行sprint的人叫做development team，而组织整个scrum的，则称为scrum master。
总结 现在我们可以看到，scrum的元素已经基本呈现出来了:
 product backlog, sprint backlog和 increment是三个工件。 product owner, development team和scrum master是三个角色 sprint, sprint planning, daily scrum, sprint review和sprint retrospective是五个事件 Openness, Courage, Commitment, Respect, Focus, 即开放、勇气、承诺、尊重、专注是五个价值观  以上就是Scrum框架的全部内容，举个例子让我们再完整的看一下: 从一开始有 product backlog，我们从中选取了几个条目放入 sprint planning， 在 sprint planning 对他进行拆分，形成 sprint backlog 和 sprint goal。有了 sprint backlog 后，团队每天会进行 daily scrum。在这个过程中，整个团队会不断进行，最终会生成产品增量 increment，产品增量会进入我们的 sprint review，而sprint review 最关键的则是对我们的产品进行反馈，反馈又会体现在一开始的 product backlog 里。</description>
    </item>
    
    <item>
      <title>useState 和 useEffect</title>
      <link>https://zhixiukang.com/posts/react-usestate-and-useeffect/</link>
      <pubDate>Tue, 21 Apr 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/react-usestate-and-useeffect/</guid>
      <description>创建函数组件方式  相比类组件其实更提倡使用函数组件，因为它在很多操作上都是很便捷的，比如说没有 this。创建函数组件的方式如下:
 // 箭头函数的形式 const Hello = (props) =&amp;gt; { return &amp;lt;div&amp;gt;{props.message}&amp;lt;/div&amp;gt;; }; // 缩写 const Hello = (props) =&amp;gt; &amp;lt;div&amp;gt;{props.message}&amp;lt;/div&amp;gt;; // 普通函数的形式 function Hello(props) { return &amp;lt;div&amp;gt;{props.message}&amp;lt;/div&amp;gt;; }  函数组件代替 class 组件 面临两个问题  没有state 没有生命周期  没有 state  React v16.8.0 推出 Hooks API 其中的一个API叫做useState可以解决问题  没有生命周期  React v16.8.0 推出 Hooks API 其中的一个API叫做useEffect可以解决问题  useEffect  模拟componentDidMount 第一次渲染  useEffect(() =&amp;gt; { console.log(&amp;quot;第一次渲染&amp;quot;); }, []);   模拟componentDidUpdate  useEffect(() =&amp;gt; { console.</description>
    </item>
    
    <item>
      <title>《好的爱情--陈果》有意思的句子</title>
      <link>https://zhixiukang.com/explore/good-love/</link>
      <pubDate>Sat, 18 Apr 2020 05:21:33 -0600</pubDate>
      
      <guid>https://zhixiukang.com/explore/good-love/</guid>
      <description>关于爱情  真正的“自信者”从容淡定，无需哗众取宠；他不追求旁人的娇宠溺爱，而安于自我的宠辱不惊。爱情世界中真正美好的“吸引力”不是一块磁铁，泛滥无度地收纳一切闲钉铁屑；而是一首诗，不知不觉吸引着那些与我心心相印的人，那些解我读我、知我懂我的心仪之人。 情是爱的谎言。情总是多的，而多情者必至寡情。与之相反，爱必然是专一的，因为它是毫无保留地全身心投入，这样的专注一定伴随着内心的忠诚。那首裴多菲的名诗《自由与爱情》中的前两句是“生命诚可贵，爱情价更高”，暂且撇开“爱”与“自由”的复杂关系，或许单单这两句诗，已然向我们暗示了“爱”的定义：只有当一种情感高于我们自身生命的价值时，它才是爱。爱需要一个人心甘情愿地用生命来垫付那极高的成本。爱就是这样一种义无反顾、心无旁骛、自我奉献，所以爱的对象怎么可能多得起来呢？哪怕仅仅是对一个人的爱，通常就足以燃尽我们的所有，包括我们自己。 “爱慕”一词揭示了爱情的这样一个真相：我爱你，因为我仰慕你，为你倾倒。爱情的起因不在于客观上你是否比别人更可爱，仅在于我只对你心存依恋、心怀向往，只希望与你朝朝暮暮长相厮守。就像禅师慧能所说的：“不是风动，不是幡动，是仁者心动。”爱情亦如是，原因不在于你是什么人、说了什么、做了什么，恰恰因为不论你是什么人，说了什么或做了什么，我都为你心动。 “我爱你”时我是永不衰竭的源泉；“你爱我”时我是不劳而获的寄生虫。在爱的领域中，当我们将“爱”无形中转换成“被爱”时，我们正堕入自私而贪婪的渊薮；我们正从心怀虔诚的天使退化为永不知足的饕餮之徒；我们开始以爱的名义克扣我们的爱人；我们用“我爱你”这一钓钩垂钓着爱人更多的付出；我们挂在嘴边的“我爱你”为我们交易来更多实际的物质、体贴的关怀、真诚的牺牲；我们说我们在“爱”，实际上我们时时刻刻在权衡计算。 伟大的歌德对爱的解读是：“我爱你，但那与你无关。”我对这话的理解是：我爱你，即使你不爱我。真正纯洁而美好的爱情一定不是用“我爱你”来交换“你爱我”，一定不是“我爱你”与“你爱我”之间的等价交易。道理很简单，我之所以爱你，不是你对我的要求，这不是一个我能够支配的选择，不是一件我可以随叫随停的事情，其实也不是一件你可以随叫随停的事情。 歌德这句话对我的震撼，在于从中我似乎领悟到：一个能专注地“我爱你”，而不计较“你爱我”的人，其心灵的力量无比强大。或者说，真正的“爱”不像我们以为的那样到处都有，它只是世间的稀罕之物，唯有那些灵魂的强者才可能拥有，才配拥有。 实际上，“我爱你”并不比“你爱我”吃亏，我们从“我爱你”中得到的也并不会比从“你爱我”中得到的少。事实上，爱之所以能令深陷其中的我们焕然一新，使我们满面桃花，并不是因为我们在被思念、被关怀、被爱；相反，是因为我们在思念、在关怀、在爱。当我们因为某一个人的声音而心潮起伏，当我们忍不住用目光追随着某一个人的一举一动而不知不觉中充满笑意，当我们将某一个人的甘苦当成自己的来对待，当我们拥抱着某一个人一如拥抱着整个世界，当我们牵着某一个人的手就像托住了自己的全部幸福，我们已然发生了完全的变化，在点点滴滴中造就了我们灵魂的“重生”。 “爱”的基础是真正的尊重和爱护，像尊重自己一样尊重他，像爱护自己一样爱护他，换言之，“己所不欲勿施于他”。在爱中，是两条溪流的交织纠缠、同步缓进，是两个生命的互相参与、共同成长，灵魂上不存在强势与弱势。所以，“我爱你”，不代表我是你的奴隶；“你爱我”，也不代表我是你的主人。 请你爱我，但是你有权利不爱。毕竟，“我爱你，那与你无关”。不管爱的是谁，不管是不是成功，只要“我爱”过，我都比很多人幸运，“我的骄傲仅在于我曾爱过，仅此而已”。 美国心理学家斯腾伯格就认为，爱情有三大元素——激情、亲密、承诺。但是这三个概念对于中文语系的人来说，可能比较难以理解，所以我借用了他的理论，然后把三个元素的名称调整成了——激情、理解、践行。我觉得一个完整的爱情，一个美好的爱情，必须要有这三大元素，缺一不可。 真正的爱，一定源于真正的了解。对一个人了解的深度，就决定了你爱他的深度。在你越来越懂他的过程中，其实还有一件事也在发生——你会越来越懂你自己。 所以什么叫作深情？你了解他是个什么样的人，你爱的就是这样一个他；你了解他最真实的样子，你爱这个真实的他。你见过他最美丽的时候，也见过他最糟糕、最丑陋的时候；你见过他最能干、最得意的时候，也见过他最失落、最狼狈的时候。在他最失落、最狼狈的时候，你还是想拥抱他，还是想吻他，这个才叫作深情。你见过他最光明的样子，也见过他最黑暗的样子，当你见到他最黑暗的样子，你还是愿意接受这样一个他，并且去爱他，这个才叫作深情。你真的懂他，懂他是个怎样的人，懂他的好与不好，懂他那些和你不一样的地方，懂他很不完美，但你还是爱这样一个不完美的他，爱他这个真实的不完美的人，这个才是真正的深情。 我们很多时候在日常生活中所说的那种“爱”，其实跟这个是背道而驰的。你喜欢他，却只是喜欢他光明美丽的一面，当你了解到他黑暗或丑陋的一面，就不喜欢他了，就想放弃他。这不是爱，而是一时情绪化的痴迷，来得快去得也快。这种痴迷不管开始时多么狂热，也很快就会消退，只是时间的早晚而已。因为它是无根之木，它需要很多虚假的美好来喂养，它容不下真实。而深情恰恰是指撇去表层的浮华，去爱他的真实。还是那句话，什么叫作深情？撇开美好的一面暂且不谈，你要知道最黑暗的他是什么样，最无力的他是什么样，最狼狈的他是什么样，最坏的他是什么样，然后你再去爱他，爱真实的他。 “我爱他们，因为他们是人；而我爱你，因为你是你。”完美的答案！我爱他们，因为他们是人，我把他们当成“人”来爱——一个人应得的尊重、应得的善待，我给他们；而我爱你，因为你是你——这里面有很深的理解，很深的懂，所以有很深的爱。 我们说“自爱基于自知”，一个人要真正了解自己，才能学会如何去爱这个真实的自己。同样地，真爱基于真知。一个人要深爱另一个人，就要首先深刻地了解这个人，然后在了解的基础之上，好好地爱这个人。 所以，爱的本质是什么？“我爱你”这句话，其实是在说——我爱你的灵魂。所以当你的肉体老去了，我还是爱你的灵魂。当你有一天变得面目全非了，我还是能在人群中，用我的灵魂辨认出你的灵魂。 不是当你说出“我爱你”这句话的时候，爱情就终结了，“我爱你”只不过是爱情的开始，重要的是接下来你要有爱的行动。爱的行动，才是爱的证明，没有行动，一切都是空洞。所以真正的爱情，就是你要真正为对方着想，真正给对方时间与关怀，很多时候，他的利益就是比我的利益更加重要，这才是真正的爱情。 我们来借用一下《圣经》当中爱的誓言，当基督徒结婚的时候，会有一个神父，或者一个牧师，主持他们的婚礼，问他们这么一段话：你是否愿意与他（她）结为夫妇，爱他（她），守护他（她），像对待你自己那样对待他（她），不论生病还是健康，贫穷还是富有，不离不弃，直到死亡将你们分开？ 我们来分析一下这个誓言。首先，你是不是能够做到，像对待自己那样对待对方？你自己想要自由，就给他自由；你需要别人理解你，就给他理解；你希望他能信任你，就给他信任；你痛苦的时候需要安慰和支持，就给他安慰和支持。所以这就是爱的行动——对他好，像对待自己那样去对待你的爱人，爱他如己，这是第一点。 第二点，爱的誓言中还说，无论是疾病还是健康，贫穷还是富有，你是否能做到对他不离不弃？这才是考验爱的行动。你想想看，他又健康又富有，你当然不离不弃了，所以这句话的重点是，当他患病的时候，你是不是还对他不离不弃；当他贫穷的时候，你是不是愿意跟他同甘共苦？这才是爱的行动。什么是爱？《说文解字》对“爱”的解释是“行貌”，是一路同行。什么是一路同行？就是不离不弃，可离可弃的都不是深爱。什么叫作不离不弃？他就是另一个你，你要像对待自己那样对待他，直到死亡将你们分开。你要知道这世界上，充满了美好的男人和女人，你是否准备好弱水三千，我只取这一瓢饮，真正地始终爱他，就像对待自己那样去对待他。这才是爱的行动、爱的践行。 然后，当神父和牧师说完这段话之后，如果你同意的话，就要说“Yes， I do”。请注意，这里说的是“Yes， I do（是，我就这么做）”，而不是“Yes， I will（是，我将会这么做）”。因为“will”这种事永远不要说，将来的事情是说不准的。“Will”说的是将来，而将来就是“从来不来”。所以这里会说“Yes， I do（是，我就这么做）”，我觉得我们中文的翻译更棒——“是的，我愿意！”这世界上，你以为最美好的三个字是“我爱你”吗？不，这世界上比“我爱你”三个字更美好的就是“我愿意”。你患病，你贫穷，我愿意跟你同甘共苦，我愿意对你不离不弃，这个才是爱。什么叫作我愿意？不是因为一纸婚姻强迫我这么做，不是因为社会舆论要求我这么做，而是因为我心甘情愿，我甘之如饴，这个才叫“我愿意”。所以，“我爱你”其实就是“我愿意”。有一天你重病了，我愿意守着你；不管你发生了什么，我都愿意在天黑的时候，带你回家。所以“我愿意”大于“我爱你”，“我愿意”才真正体现“我爱你”。 以上三大爱情元素，看上去好像彼此独立，但其实是环环相扣、缺一不可的。爱情是全身心的，激情、理解、践行——“激情”意味着我爱上了你，“理解”意味着我懂你，“践行”意味着我愿意陪你一路同行，不离不弃。只有当这三者合并在一起，才叫全身心，只有这三个要素都存在的时候，才有了“我爱你”。 很久以前，我看过 D·H·劳伦斯的书，他是这样形容爱情的：“之前，你是一条河，我是一条河，当我们认识之后，两条河交汇到了一起，从此以后，分不清哪条河是你，哪条河是我，因为我们汇成了一条河，叫作我们。”当时我觉得这是非常朴素的一句话，却说得非常非常动人。所以什么是真挚美好的爱情，那就是在这段爱情关系当中，没有非常鲜明的我，没有非常鲜明的你，但是有一个非常鲜明的我们。换言之，在这个美好的爱情关系当中，你也是我，我也是你，我们不分彼此。你的幸福就是我的幸福，你的痛苦就是我的痛苦。别人对你好，就是对我好，就是对我们好；别人欺负你，就是欺负我，就是欺负我们。 在西方的传说中，女人是男人的一根肋骨，是男人身体的一部分。如果没有这根肋骨，男人即使看起来再强大，仍是不完整的，生命仍有缺憾。同样地，女人若没有找到那个化生出自己这根肋骨的男人，即使再美丽灿烂，也很难获得真正欢乐幸福的生活。爱情中的双方，就像一对天造地设的齿轮，无论是精神还是身体，无论在时间这条履带上转动多久，彼此总能凹凸相应、长短互补、紧密咬合。 所以每一个正在找对象的人，在结束你的孤狼生涯的过程当中，不要渴望去寻找一个完美的人，觉得他必须要这样，要那样，要具备 ABCDEFG 这些条件。你要想想，你自己完美吗？你要是不完美，那你配得上完美的人吗？不要试图去寻找一个完美的人，因为在完美的人身边，你是多余的，完美的人不需要别人。所以，爱情不是你和一个完美的人相爱了，而是他爱了你之后，他才更趋完美了。 爱情就是两个不完美的人，共同创造一个完美的关系。这段完美的关系，蕴藏着无穷的力量，所以爱人之间是可以做出很多特别富有创造力的、奇迹般的、超乎常人逻辑思考能力的事情的。 死亡是强大的，最终能带走所有人的鲜活生命，而堪与死亡相抗衡的唯一对手，便是“爱”。死亡不能带走爱，不能稀释爱，不能消灭爱。相反，爱超越了生命，所以超越了死亡。爱抓不住逝者的呼吸，却拥有逝者的灵魂。爱使我们生而完满，所以死而无憾。爱使生命放光，连死亡也跟着沾光，不再显得那么黑暗可怕。爱是灵魂燃烧的火，除了灵魂的消散，没有什么能将它熄灭。《圣经·旧约》的《雅歌》说到“爱如死般坚强”，可能就是这个意思吧——生命可死，爱永生。 我们小时候学散文，当时老师说散文“形散而神聚”。我觉得爱情也是这样，形散而神聚。我们可能在不同的教室上课，但我心里有你，你心里有我。我们各自笔记上记下来的东西，各自听到看到的趣闻和伤心事，我们会一起分享。这个就是形散而神聚。我们可能在各干各的事情，但是空气当中有一种我们的共振，只有非常非常敏感的人才能感觉到我们的这种共振，这就是不同的身体，同一个灵魂。 爱的最高境界，除了“为爱而死”，还有“为爱而生”。与“为爱而死”同等境界的，就是“为爱而生”。我的爱人死了，我也陪他去死，这个境界高吗？高的。我的爱人死了，我替他去活，这个境界也是高的。我用我的生命活出他的生命，我替我们去活，这个也是最深的爱。 真正去爱一个人，不是要把他当神来爱，而是要把他当成一个真实的人来爱。真实的人有很多脆弱，真实的人有很多缺点，真实的人是不可能完美的。所以你真正爱一个人，不要把他当作一个完美的人来爱，也不要把他当成一个神来爱，觉得他毫无瑕疵、全是优点、高高在上。你以为你是在爱他，其实你是在剥夺他的人性，剥夺他真实而不完美的权利。真爱不是把对方当成神来爱，否则对方的压力会很大的，谁能够长期扮演“神”啊？他如果成不了神，那就只能做骗子了。不是吗？ 所以，真正爱一个人，就把他当成一个真实的平常人来爱。用平常心看待他，用平常心对待他，用平常心爱他——爱这个平常的人，爱你心中这个平常的女孩或男孩。他有缺点太正常了，他会做错事太正常了，平常人就是有缺点的，平常人就是会做错事的，对不对？ 有一部英国电影，叫作《BJ 单身日记》。里面的男主角是霸道总裁型的完美绅士、万人迷，而女主角则长得矮矮胖胖，按照现在的审美标准，不是很性感，不是很迷人，不是风情万种的那种。她一直觉得那个男主角不会看上她的，因为两个人看起来一点也不般配。实际上，男主角很喜欢女主角。他很腼腆，不知道该怎么向她表白，后来他就语无伦次，结结巴巴地对女主角说了这么一句：“I love you as who you are”——我爱你，如你所是。 我爱你，不是因为你完美。我爱你，就因为你是你，我爱的就是这个你，我爱的就是真实的你。这就是 I love you as who you are，我爱你，如你所是。我觉得这才动人啊！我爱你，因为你是你，换个人我就不爱了，哪怕他比你完美，比你有钱，哪怕他在别人眼里比你更有魅力，但是我爱你，爱的就是你，因为你是你，如你所是。真爱就是这样的。 生活中我们常把一种强烈的爱说成是“恨铁不成钢”，但在真爱中，不存在“恨铁不成钢”。如果你真的爱他，你了解到他是一块铁而不是一块钢，那么你会把他当一块铁来爱，让他自由地成为一块铁，并且因为你的爱而成为这个世界上最美满的一块铁、最幸福的一块铁。 如果你爱的是钢，发自内心地爱钢，而你了解到他是一块铁，那么请你放过这块铁，不要用你所谓的“爱”强行把这块铁锻造成你理想中的钢，他没有这个义务，也许也根本没有这个天性和意愿去成为你想要的钢。如果你爱的是钢，而他是块铁，请你放过他，请你继续去寻找、等待、追求你的那块钢，而让这块铁安安静静地等待那个真正爱他的人，那个发自内心珍惜和善待这块铁的人。 我们都了解，人们对“爱”充满误解，总是在用爱的名义滥用爱。对爱的滥用当中最常见的一种，就是用爱的名义来强加自我的意志。“恨铁不成钢”就是这样一种强加意志，谁告诉你我非要成为钢不可？谁说钢就一定比铁更可爱？ 当我们强加意志时，经常用到一个完美的理由——“我是为你好”。我告诉你，你应该这样做，应该那样做，为什么呢？我这一切都是为你好。但请想一想，我所认为的“好”就一定是真的对你“好”吗？我说我是“为你好”，可你真的觉得好吗？你到底是不是更好了，这件事由谁说了算呢？是以我为准，还是以你为准呢？ 所以，真正的爱，不是强迫你成为我想让你成为的样子，而是我用心地读懂你，然后尽心尽力帮助你成为你自己。真正的爱不是把你变成你所不是的人，而是深刻地了解你，然后让你做你自己，让你活成真实的你。 我们总说，爱一个人，就要保护他，不让他受伤害。是的，保护他不被别人所伤害，更要保护他不被我所伤害。 我们日常生活当中，常常有这么一个误解，就是我们觉得日久年深的爱情，会自然而然归于平淡，最终必然走向亲情。为什么呢？我们常说，两个人相爱时间长了，就是左手握右手，没感觉了，只是一种习惯了。我们很多时候对于这种现象的解释就是：激情消退了，热情不再了，没有你侬我侬了，爱情变淡了。真的是这样吗？激情是一个人内心翻腾涌动的热潮，是一种深深的眷恋。你以为它必须是汹涌澎湃的表达方式吗？不是这样的。汹涌澎湃的激情说明不了两个人感情深，倒有可能反衬出感情浅。因为只有感情浅的时候，才需要用外在形式的剧烈夸张来弥补两个人灵魂交错的深度。日久年深的爱情仍充满激情，它只是变成了另外一种更为温润细腻的表达方式。 我还认识一位女音乐家，她结婚的时候 40 多岁，她的丈夫 50 岁，他们都是第一次结婚。你们想想，她等了 40 多年，就是在等他；而他等了 50 年，就是在等她。年轻人之间的那种火辣辣的激情，在他们身上很少看见，但是你会感觉到他们之间有一种很浓很深的热情。当他们与朋友聚会时，无论那位女音乐家走到哪里，她丈夫的目光都会不自觉地跟到哪里，而他的目光里，一直有一种深深的笑意，他脸上没有笑，但是他整个人化成了一个笑意，化成了一个微笑，他的妻子就是他心里最深的喜悦。这就是发生在他们之间的属于他们的一种激情。 所以很多时候，我们以为爱的时间长了，感情就淡了，激情就没了。错了错了，不是淡了，恰恰是深了，深到骨髓里去了。因为太深了，所以表面上你是看不出来的。很多时候，我们以为激情就是怀着一种激动的心情，四目相望，互相说一句“我爱你”，我们觉得这才是激情。其实不然，这世上最深的激情，是两颗心之间的默契。什么叫作默契？默契就是心意相通，精神共振，融为一体，就是两个人永远在一个频道上，在精神上无缝对接。这才是默契，而默契才是最深的激情。 要保持爱情长久的一个方法，就是要尽可能保持你们在精神上的同步而行。如果你的发展跟他的发展不一样，你们要多沟通，多交流。两个人的距离不是突然间变大，变得遥不可及的。如果你思想的进步、精神的成长比他快，请你拉他一把，帮助他成长，并跟他一起成长，这才叫作身体力行去爱他。不要让你自己离他太远，不论在生活上还是精神上都是如此。爱情就是心灵的结合，心要是走远了，爱情就散了，就淡了。 我有个朋友，跟他妻子关系一直非常好，每年他们两个人都要共同学一样新东西，比如有一年他们两个人共同学画画，有一年两个人共同学吉他，有一年两个人共同学厨艺，还特地一本正经地上了个厨艺学校，互相切磋，一起烹饪两个人的幸福。 还有一次，我问一对恩爱夫妇，他们是如何保持激情永不消退的？他们的回答是：“你要不断地发现他身上美好的东西，新的美好的东西，然后你就会一次次地爱上不同的他，一次次地爱上同一个人。”所以，你不要以为你只是你，总是一成不变的那个你。其实你每天都会接触到一些新的人、新的事物，产生一些新的想法，会有新的成长。其实每天你都在变化，都与昨天的你有所不同。然后那个跟你在一起的人，或许他发现了你的这些变化，或许正是他促成了你的这些变化，这些变化使你变得不同，然后他又爱上了这个不同的你，爱上了每一个不同的你，他一次又一次地爱上了你，爱上了同一个人。 这其实是很浪漫很浪漫的事情——一次又一次地爱上同一个人。不要以为浪漫是花钱的事情，那是浪费。浪漫不需要用钱，而需要用心——用心地了解他，用心地发现他不同的美，然后爱上每个不同的他，这样你等于每一次都在跟一个不同的人谈恋爱。虽然他看似是同一个人，但是他一刻不停地在成长。二十岁的他跟三十岁的他肯定不一样，然后四十岁的他又不一样，所以你一次又一次爱上了不同的他，千万个他，却也一次又一次爱上了同一个人。在这个过程中，其实你在见证他生命的转变，也参与了他人生的成长。这是爱情最美好的一种状态，千变万化，却始终如一。 另外，在爱情中还有这么一个说法，“谁要认真谁就输了”，这句话真是俗不可耐。如果你抱有这种想法，那么你追求的不是爱情，你追求的只是征服。如果一个人他认为爱你就是征服你，那我觉得他不是真的爱你，你只是他的战利品，是他挂在胸前的一枚勋章而已。他在意的不是爱情，而是输赢。 那么，什么叫作爱情呢？哪怕我会输，我还是要爱，我还是要认真，这才是爱情。它的格调很高的，爱情就是个高格调的东西。它不是一种征服欲的实现，或者一种占有欲的表达。 坦率地讲，你如果真的在爱情之中，你是很难不认真的。不认真的叫作套路，而真的爱情就是用心，用心的东西你还能不认真吗？可能有人会反驳说，我们可以用心地玩套路，但那就不是爱情了，而是阴谋。真正的爱情，不计较输赢，即使可能会输，我还是会全心全意认真地爱你。 很多时候，我们可能不甘心被人征服，每个人都有自己的骄傲，你可能觉得征服别人，让别人死心塌地地爱上你是件光彩的事情，但被人征服，死心塌地地爱上别人就挺丢脸的。其实真正的爱情，是不会太在意面子的。在所有的被征服中，被爱征服是最不丢脸的，硬要说丢脸，那也是最甜蜜的一种丢脸，丢脸就丢脸呗！事实上，在爱情中，不是一个人征服了另一个人，而是你们共同被爱征服。被爱征服，成为爱的门徒，这多幸运啊。 爱情肯定是要吵架的，但吵架不一定就是一件坏事，所谓“吵架”其实就是一种疯狂的交流——这种非常状态的对话模式能够帮助你看到非常状态的他，更好地理解他是个什么样的人。平时我们都被理智操控，表现得各种得体，各种端着，一吵架面具掉了一地，真性情就暴露了。所以，在爱情关系中，吵架有它不可替代的重要性，很多时候它能帮你全面了解一个人。 我曾问一对老夫妇，吵完架之后该怎么去修复呢？他们告诉我：“你要相信一件事，月有阴晴圆缺，每一次阴晴圆缺之后，会是下一次阴晴圆缺。所以不要担心吵架，这一次是阴是缺的时候，你心里要有一份信仰——这阴和缺是阶段性的，它很快就会迎来下一次的圆和下一次的晴。而永恒的爱情，那就是你和他一起，共同度过一次又一次的阴晴圆缺。”所以，我们要用平常心来看待吵架或爱情关系中的低潮，这些都是爱情生活的一部分，你知道它还会变好的，你知道你会努力让它变好的，你知道前面还有很多很多美好的生活在等着你们，你知道你还是愿意和他一起去创造这份美好，这就是一种信仰，而爱是需要信仰的。越是在困难的时候，越是愿意去坚持，这恰恰是爱的一种强度的证明。  成熟与自由  一个完整的“大人”应该包含生理的成熟和心理的成熟，他是身体的成人，也是精神的成人。 一个人精神上是否成熟，跟这个人的生理年龄没有必然关系，它们不一定成正比。就像我们生活中有很多人身强力壮，人高马大，有些甚至白发苍苍，他们生理上毫无疑问已经成熟了、熟透了。但是，如果你仔细去观察他的所言所行，就会发现在他成年人的外表下仍然住着一个幼稚不懂事的小孩，他既没有自知之明，也没有任何担当，自相矛盾，缺乏勇气。时间只是让他变得油滑奸诈、胆怯忸怩，却没有让他变得更有见地，更加成熟。 在这里，我引用了陈寅恪先生所说的“精神之自由，人格之独立”，这是一个人的内在气象。而我又在后面加上了自己的观点“责任之担当”，这是一个人把他的内在气象外化为一种生活的态度与实际的行动。精神之自由、人格之独立、责任之担当——我觉得唯其如此，才能算得上是一个真正完整的、纯正的、成熟的“大人”。 嚎啕大哭不一定就是坏事，不会嚎啕大哭也不一定就意味着幸福。一个不会嚎啕大哭的人，往往也不会开怀大笑。因为大哭也好，大笑也好，本质相同，说明你的心是鲜活的，因为只有鲜活的心才对一切具有敏感性，这敏感性使它能真正感觉到快乐而开怀大笑，也能真正感觉到悲伤而嚎啕大哭。当一颗心对悲伤不再敏感，那它对快乐也不会再敏感，这是同步的。 你想想看，什么叫作“为所欲为”？为所欲为，其实就是“为‘欲’之所为”——你在做欲望让你做的事情。你的欲望让你做什么，你就做什么。这时你是被欲望支配，被欲望操控，被欲望牵着鼻子走。不是你在主宰你的欲望，而是你被你的欲望所主宰，你不是欲望的主人，却成了欲望的奴隶。当你被别人奴役的时候，你会说你不自由。当你被自己的欲望所奴役的时候，你却说那是自由。这不是很好笑吗？其实这里面“换汤不换药”，还是一回事啊！你之前的不自由感是来自于他人的束缚，现在好了，他人不束缚你了，你却开始用欲望来束缚你自己了。所以，你还是不自由的，因为你根本不是自己的主人，你还是一个奴隶，只是换了主人而已。一个奴隶，不论你是谁的奴隶，你终究不是自己主宰自己，又能有什么自由可言呢？ 逃避和对抗任何一样东西都不会带来真正的自由，“逃避”和“对抗”这两件事就意味着强烈的不安、焦虑与慌乱。当你像一个逃犯一样逃避或对抗任何一样东西，你的内心都不会有安宁、放松与平和。可恰恰是内心的安宁、放松与平和，才真正通向自由。 真正的自由者，没有内部的对抗与暴力。他不像其他人那样总是处在自我理智与情感、责任与欲望的激烈挣扎中，他总有办法让他的理智与情感相安无事，让他的责任与欲望相亲相爱，他和他自己相处融洽。每一个自由者都是一个精神的自洽者。 真正活得自由，不代表你要活得多特别，你可能看起来跟大家活得一样，但是你这样活，不是因为大家都这么活，也不是因为大家都不这么活。你这样活，是因为你喜欢这样活，因为这就是你发自内心想要的生活。自由或者不自由的根本，不在于你“干什么”，而在于你“为什么这么干”，你是否心安。你走这条路，不是因为很多人走，也不是因为从没有人这么走，这些都是影响自由的杂念。你走这条路，很简单，就是因为你想走，因为这是你的路。 什么是真正的自由？在法律和道德的底线之上，你可以作任何选择。这个选择可能跟大家一样，也可能跟大家不一样，这不重要。重要的是，你这么选择，是因为这是你想要的，这让你感到心安。心安处即故乡。 我有个朋友，很接近这里所说的“自由者”的状态。别人对她的评价是：太阳每天升起降落，但你是墙角一朵按照自己的花期开放的小花。真正的自由者，不在意别人按照什么节奏去生活，因为他找到了自己的节奏，他按照自己的节奏去生活，不去干扰别人，而别人也很难干扰到他。这才是真正的自由。 那么，我们要怎样做到这种自由呢？ 第一，清醒的自知；第二，勇敢的选择；第三，坦然的无悔的担当。真正自由的人，如果你做到了这三点，你会发现你的心态永远是安宁的，因为你想清楚了，你决定了，所以你愿意担当。因为是你自己选的，所以即便结果不如人意，你也会坦然接受，无怨无悔，这就叫高贵。 自由不只是一个人敢为天下先，更是敢做敢当，愿赌服输。自由不是什么都能去做，而是你作好你的选择，然后担当起你所选择的。苦也好，乐也好，成也好，败也好，你选择，你承担，你心安。选择并担当，这才是自由的全部内涵。 自由不是自我放纵的力量，恰恰相反，自由体现的是一种自我节制的力量。我饿了就吃，这算什么力量？我饿了的时候，因为某种原因我选择不吃，我甘心节制某种欲望来成全精神的不受束缚，这种精神的自我节制才真正体现了一个人的自我主宰，这才叫力量。所以，很多时候“自我节制比自我放纵更接近自由”。很多人喜欢说“有钱就是任性”。其实有钱任性，这没什么稀奇的，这就像你饿了就吃一样，里面没有任何自我的精神力量。这或许体现了钱的强大，却并不能体现你的强大。你有钱却不任性，或者你没钱却还能很率性，这才能体现一个人的内在力量 我觉得“老”是一个生理的阶段，但成熟与否是一个心理的状态。“老”属于现象界，“成熟”属于精神界，它们分属两个不同的维度，位列两个不同的界面。所以我希望各位在这一点上要有常识，对人的成熟也要有一定的鉴别力。我们经常说一个词——衰老，其实这两个字不应该放在一起，“衰”指的是人精神的沉沦和堕落，而“老”指的是人身体的退步和退化，它们是不同的东西。 那什么是“老”？老指的是身体的退化，就是你身体的各个关节可能不怎么灵活了。但是我们也会发现，我们生活中也充满了一种人，老而未衰，老而不衰。他年龄的增长，只是让他的气象更加清澈，让他的精神状态更加澄明。你会觉得，这样的人是在越来越老，但是他同时也越来越纯洁，越来越通透，越来越美丽。 我曾经和我的朋友分享过一个心得：我们不可改变的是我们一直在变老，但是有没有一种力量可以抵抗变老？变老是一种向下的力量，有没有一种往上的力量可以对抗变老？有！这就是成长！这是我对自己的要求，这里也跟大家分享——在精神上向着光，向着高空，不断地升华和成长。因为唯有成长，才能够抵御住变老的那种向下的力量。你会慢慢地活成一束光，谁若接近你，就是接近光。这应当是人生在世，对自己的一种责任和使命，我是这么想的。人只活一次，你怎么舍得自己短暂的一生是丑陋的、卑污的？你怎么舍得让自己短暂的一生只是往下坠落？即便是坠落，也应该具有落日般的华丽。 所以，精神的成熟者，他对外表现出来的不是老，而是一种内部世界的和谐，对任何事都很从容，心灵总是很清明，胸襟总是很坦荡，这才是真正精神成熟的人。 《中庸》里说“唯天下至诚，为能尽其性”，这里的“性”包含了人和物——“尽人之性”和“尽物之性”。意思是，只有心怀一片诚意，才能使一个人或一件东西发挥出其最大的潜能与力量。 大学之道，“在止于至善”。什么叫“止于至善”？就是致力于将“至善”作为自己一生的追求。因为至善永不可达，所以重要的不是达到“至善”这个结果，而是在追求至善的路上，不断自我完善、自我进化、自我超越的过程。正是这个过程让我们循序渐进靠近至善，也正是这个过程，在不知不觉中让我们成长为一个伟大心灵，一个顶天立地有浩然正气的“大人”。 大学”。我很喜欢法国作家夏尔·波德莱尔，他有句话让我印象很深，他说，这世界上只有两件有价值的事：第一件是你深感惊喜；第二件是你使人惊喜。延伸开去，我觉得这世界上只有两件有价值的事：第一，你要好好活着；第二，请你在自己好好活着的同时，帮助别人好好活着。再有：第一，你要尽一切努力，让自己活得幸福；第二，在你获得幸福的同时，要给别人幸福。 孔子在 73 岁离开这个世界时，说他自己“大节无亏，可以安然去也”。什么叫大节无亏？就是这辈子你没有一个必须要说的谢谢，因为你没有亏欠谁；这辈子你也没有一个必须要说的对不起，因为你没有伤害谁。大节无亏，可以安然去也，我觉得这真的是顶天立地的大人。 友情也是无用的，友情要是有用，那就叫人脉，而不叫友情。真正的友情，你不会向它索取，反而会为它作出自我牺牲。你对朋友不会作出要求，他在那里就够了，世界上有这个人在就够了。 正是这些在经济学上“无用”的东西，这些不具有实用性的东西，让你看到了自己的真挚与温柔。有用的东西能让你看到物质的美好，无用的东西能让你看到一个美好的自己。你会喜欢这样的自己，对这样的自己深感满意，而这更接近幸福的本质。  人啊，认识你自己  第一句，“保持内心的沉静”。第二句，“学会倾听”。第三句，“做你认为正确的事”。 前一段时间我和一个朋友聊天，他突然问我一个问题：“你觉得人最害怕什么？”我说：“大多数人应该最害怕死吧。”他说：“不，我觉得人最害怕黑暗。人对黑暗一定是格外恐惧的。人为什么害怕孤独？因为孤独就是内心的黑暗。人为什么害怕死亡？因为死亡就是永恒的黑暗。”我想确实是这样的，人一定非常害怕黑暗，所以在西方的信仰中，他们的神创造世界的时候，第一个就是“要有光”，于是有了光。人一定非常害怕黑暗，所以“光明”一词对人类而言意义非凡。 你们从来不觉得奇怪吗？为什么丘比特射箭的时候要蒙着眼睛，他为什么不睁开眼睛？为什么法庭门口的正义女神也是蒙上眼睛的？为什么《荷马史诗》的作者荷马是个盲人？要知道，丘比特必须蒙上眼睛，正义女神必须看不见，荷马必须是盲人。为什么呢？《小王子》告诉了我们原因：只有心灵才能够洞察一切，用眼睛是看不到事物的本质的。他们必须蒙上眼睛，他们必须看不见，因为，世界上真正重要的东西，不是你能用眼睛去看的，而是要用你的心去看。只有用你的心去看的时候，你才能够看清楚本质与真相。 西方文化将目光与思想指向人心以外的这个大千世界，它向外求索，追问世界的根源，追问人作为世界的一部分，具有怎样的属性。而东方文化将它的目光与思想转向了人心以内的那一片精神世界，它向内求索。西方文化看世界，看天空，看土地，看高山和大海；东方文化看自己，看自己的心，看自己的本色与天性，看悲欢离合中人心如何受困与解脱。我曾经读到过一句有趣的话，说人为什么会睁眼与闭眼，人睁眼是为了看这个世界，而人闭眼是为了看自己。东方文化追问世界的方式、追问存在的途径，不是问天问地，而是扪心自问，所以我们长久生活于其中的东方文化，格外注重反躬自省，格外注重明心见性。 以何眼观世界，就观到何种世界。一个人的心眼其实不知不觉中决定了他的双眼；一个人的境界其实不知不觉中决定了他的眼界。佛印有佛心，以佛眼观世界，所见之处，处处是佛；苏东坡有贼心，以贼眼观世界，所见之处，处处污秽。 其实人的一生中所做的任何一件事、学的任何一门学问、遇见的每一个朋友、每一个敌人，都是一条路，都通向自我认识。所以世界上最后只剩下了两件事：第一，know who I am，认识我自己；第二，be who I am，尽力成为我所是。人生的所有事件都指向这两件事：认识我是谁，然后努力成为我所是——知我所是，如我所是。有朝一日当别人问你“who are you”，你是谁？你的回答也会是“I am who I am”，我就是我。而当一个人敢说“I am who I am”的时候，你已是半神，你已然成为了与老、庄、孔、孟平级的人，与他们同等能量的人。就像我们中国文化对“神明”一词的解释——神，是精神；明，是明澈。所以，当你活到精神明澈，你已然美若神明。 很多时候，我们以为是自己作了一个决定，其实幕后的很多人已然帮我们作了选择。所以你看，为什么在英语当中，Mr.</description>
    </item>
    
    <item>
      <title>Vue: 进阶构造属性</title>
      <link>https://zhixiukang.com/posts/vue-options-advanced-examples/</link>
      <pubDate>Wed, 15 Apr 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/vue-options-advanced-examples/</guid>
      <description>之前在Vue: 构造选项 里罗列了options 的五类属性，今天就把剩下的关于资源和组合的属性说一说。
 directives、 mixins、 extends、 provide、 inject
 directives - 指令 自定义指令  我们已经学了一些内置指令   如 v-if、 v-for、 v-show、 v-html等
  今天学习如何自己造一个指令   目标: 造出v-x， 点击即出现一个x
 两种写法  声明一个全局指令  Vue.directive(&amp;quot;x&amp;quot;, directiveOptions);   这样你就可以在任何组件里用v-x了，动手试试
  声明一个局部指令  new Vue({ ..., directives: { &amp;quot;x&amp;quot;: directiveOptions } })   注意，v-x只能用在该实例中，动手试试
 directiveOptions  上面例子中的directiveOptions里有哪些属性？
 五个函数属性  bind(el, info, vnode, oldVnode) - 类似created inserted(参数同上) - 类似mounted updated(参数同上) - 类似updated componentUpdated(参数同上) - 用得不多，见文档 unbind(参数同上) - 类似destroyed  举例  自制 v-on2 指令，模仿 v-on  main.</description>
    </item>
    
    <item>
      <title>Vue: 模板、指令与操作符</title>
      <link>https://zhixiukang.com/posts/vue-template-directives-and-modifier/</link>
      <pubDate>Fri, 10 Apr 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/vue-template-directives-and-modifier/</guid>
      <description>模板 template 三种写法 Vue 完整版，写在 HTML 里 index.html:
&amp;lt;div id=xxx&amp;gt; {{n}} &amp;lt;button @click= &amp;quot;add&amp;quot;&amp;gt;+1&amp;lt; /button&amp;gt; &amp;lt;/div&amp;gt;  main.js的new Vue()的options里就不需要写template属性:
new Vue({ el: &#39;#xxx&#39; data:{n:0}, // data可以改成函数 methods:{add(){}} })  Vue 完整版，写在选项里 在index.html里写好挂载点:
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;  main.js的new Vue()的options里写template属性:
new Vue({ template: ` &amp;lt;div&amp;gt; {{n}} &amp;lt;button @click= &amp;quot;add&amp;quot;&amp;gt;+1&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;`, data: { n: 0 }, methods: { add() { this.n += 1; }, }, }).$mount(&amp;quot;#app&amp;quot;); // 注意一个细节: div#app会被替代  Vue 非完整版，配合 xxx.vue 文件 xxx.</description>
    </item>
    
    <item>
      <title>Vue: computed和watch</title>
      <link>https://zhixiukang.com/posts/vue-computed-and-watch/</link>
      <pubDate>Mon, 06 Apr 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/vue-computed-and-watch/</guid>
      <description>回顾一下响应式原理  完整文章: Vue: 深入理解数据响应式 | 修
 options.data  会被Vue监听 会被Vue示例代理 每次对data的读写都会被Vue监控 Vue会在data变化时更新UI  本篇文章讲  data变化时除了更新UI，还能做些什么？  computed - 计算属性 用途  被计算出来的属性就是计算属性  例子一:  用户名展示  main.js
// 引用完整版 Vue，方便说明 import Vue from &amp;quot;vue/dist/vue.js&amp;quot;; new Vue({ data: { user: { email: &amp;quot;hahaha123@gmail.com&amp;quot;, nickname: &amp;quot;修&amp;quot;, phone: &amp;quot;18832388888&amp;quot;, }, }, computed: { displayName: { get() { const user = this.user; return user.nickname || user.email || user.phone; }, set(value) { console.</description>
    </item>
    
    <item>
      <title>Vue: 深入理解数据响应式</title>
      <link>https://zhixiukang.com/posts/vue-reactivity-in-depth/</link>
      <pubDate>Fri, 03 Apr 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/vue-reactivity-in-depth/</guid>
      <description>通过这篇文章，深入理解一下options.data，方便之后学习options的进阶属性。
  主要原理在文档的深入响应式原理章节可以找到，但是本篇文章扩充了非常多的内容。
 Vue 对 data 做了什么  重要议题
 小实验 - data 变了  示例代码: myData居然变了 一开始是{n:0}，传给new Vue之后立马变成{n: (...)}   {n: (...)}是个什么玩意，为什么表现和{n:0}一致？
  我们需要先看一下ES6的getter 和 setter
  示例代码 学完之后呢？还是不理解{n: (...)}呀。   我们需要再看一下Object.defineProperty() | MDN
  看完了，还是不理解:( 继续试验   现在理解了吗？
 示意图  如果data有多个属性n、m、k，那么就会有get n,get m,get k等
 getter 和 setter  定义的时候可以直接去设置一个getter和setter
 来两个例子:
const obj = { log: [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;], get latest() { if (this.</description>
    </item>
    
    <item>
      <title>Vue: 构造选项</title>
      <link>https://zhixiukang.com/posts/vue-options/</link>
      <pubDate>Tue, 31 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/vue-options/</guid>
      <description>创建 Vue 实例 const vm = new Vue(options);  内存图  把Vue的实例命名为vm是尤雨溪的习惯，我们应该沿用
  vm对象封装了对视图的所有操作，包括数据读写、事件绑定、DOM更新 vm的构造函数是Vue，按照ES6的说法，vm所属的类是Vue options是new Vue的参数，一般称之为选项或构造选项   构造选项(构造函数后面的选项)
  图中一共有五个问号，我们一个一个地来了解
 图中的 5 个问号  我们在初始化的时候，到底能写些什么对象进去？   options的参数有哪些？
 这个vm对象有哪些属性？ Vue函数本身有哪些属性？ Vue.prototype有哪些属性？   函数的原型有哪些属性？
 Vue.prototype后面还有没有什么prototype?   函数的原型还有没有原型？
  可能还需要几篇博客来回答这五个问题，一旦把这五个问题回答清楚了，Vue就全部懂了
 options 的五类属性 数据  选项 / 数据 - Vue.js
  data、props、propsData、computed、methods、watch  DOM  选项 / DOM - Vue.js
  el、template、render、renderError  生命周期钩子  选项 / 生命周期钩子 - Vue.</description>
    </item>
    
    <item>
      <title>Vue: 起手式</title>
      <link>https://zhixiukang.com/posts/vue-getting-started/</link>
      <pubDate>Sat, 28 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/vue-getting-started/</guid>
      <description>Vue目前不是一个MVVM框架(Vue 1是MVVM框架)，Vue现在是MV* 框架
  中文文档 — Vue.js
 Vue自学线路图 项目搭建  目标一: 搞出一个使用Vue的项目
 方法一: 使用@vue/cli  安装 | Vue CLI
  创建一个项目 | Vue CLI
  安装**@vue/cli**  yarn global add @vue/cli   可以通过vue --version查看是否安装成功
  创建一个项目  vue create vue-demo   路径可以使用.，在当前目录下创建一个项目
  本文中的Vue选项   这次的选项只适合本篇文章，如果是真实项目，请自行斟酌选项
  使用空格选中或取消
  开启webpack-dev-server  cd vue-demo yarn serve   扩展阅读: Vue CLI</description>
    </item>
    
    <item>
      <title>WebPack的使用及思路</title>
      <link>https://zhixiukang.com/posts/guide-to-webpack/</link>
      <pubDate>Wed, 25 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/guide-to-webpack/</guid>
      <description>webpack每年升级, 本文基于webpack@4.43.0。
  即使版本升级，每部分细节会有变化，本文思路依然有效。
 webpack是干什么的  转译代码   ES6转为ES5, SCSS转为CSS
  构建build 代码压缩 代码分析  安装webpack  webpack@4   如果webpack升级到了5，本文的思路依然有效
  webpack-dev-server   用于本地预览
  查看webpack版本:npm info webpack
 在一个文件夹里引入webpack  Getting Started | webpack
 mkdir webpack-demo cd webpack-demo npm init -y // 创建了package.json yarn add webpack webpack-cli --dev // 多了一个node_modules目录  如何调用本地安装的webpack ./node_modules/.bin/webpack --version   简易写法:  npx webpack   不够稳定，不能使用的话，就用上一种方法</description>
    </item>
    
    <item>
      <title>MVC和重构</title>
      <link>https://zhixiukang.com/posts/mvc-and-code-refactoring/</link>
      <pubDate>Sat, 21 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/mvc-and-code-refactoring/</guid>
      <description>MVC 是什么  M-Model (数据模型)   负责操作所有数据
  V-View (视图)   负责所有 UI 界面
  C-Controller(控制器)   负责其他
 // 数据放在m const m = { data: {}, // 对数据增删改查 create() {}, delete() {}, update(data) {}, get() {}, }; // 视图放在v const v = { el: null, html: ``, init(container) { v.el = $(container); }, // 渲染函数，参数将是数据。视图全都是对数据渲染 view = render(data) render(x) {}, }; // 其他放在c const c = { init(container) {}, events: {}, add() {}, minus() {}, mul() {}, div() {}, // 自动绑定事件 autoBindEvents() {}, };  代码重构 最小知识原则  引入一个模块需要引入 html、css、 js 引入一个模块需要引入 html、js 引入一个模块需要引入 js 你需要知道的知识越少越好,模块化为这一点奠定了基础   在 ES6 中，可以使用 import 关键字引入模块，通过 export 关键字导出模块</description>
    </item>
    
    <item>
      <title>跨域、CORS、JSONP</title>
      <link>https://zhixiukang.com/posts/cross-domain-cors-and-jsonp/</link>
      <pubDate>Wed, 18 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/cross-domain-cors-and-jsonp/</guid>
      <description>跨域关键知识  同源策略   浏览器故意设计的一个功能限制
  CORS   突破浏览器限制的一个方法
  JSONP   IE 时代的妥协
 同源策略  不同源的页面之间，不准互相访问数据
 同源定义 源  window.origin或location.origin可以得到当前源 源 = 协议 + 域名 + 端口号  如果两个 url 的  协议 域名 端口号 完全一致，那么这两个 url 就是同源的  举例  https://qq.com、https://www.baidu.com不同源 https://baidu.com、https://www.baidu.com不同源  完全一致才算同源
   同源策略定义 浏览器规定  如果 JS 运行在源 A 里，那么就只能获取源 A 的数据 不能获取源 B 的数据，即不允许跨域  举例(省略 http 协议)  假设frank.</description>
    </item>
    
    <item>
      <title>异步、回调和Promise</title>
      <link>https://zhixiukang.com/posts/asynchronous-and-callback-and-promise/</link>
      <pubDate>Sun, 15 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/asynchronous-and-callback-and-promise/</guid>
      <description>JS 异步编程模型
 同步、异步、轮询和回调 如果能直接拿到结果  那就是同步 比如你在医院挂号，你拿到号才会离开窗口 同步任务可能消耗 10 毫秒，也可能需要 3 秒 总之不拿到结果你是不会离开的  如果不能直接拿到结果  那就是异步 比如你在餐厅等位置，你拿到号可以去逛街 什么时候才能真正吃饭呢？ 你可以每 10 分钟去餐厅问一下(轮询) 你也可以扫码用微信接收通知(回调)  异步举例 以 AJAX 为例  request.send()之后，并不能直接得到response  不信console.log(request.response)试试
  必须等到readyState变为4后，浏览器回头调用request.onreadystatechange函数 我们才能得到request.response 这跟餐厅给你发送微信提醒的过程是类似的  回调 callback  你写给自己用的函数，不是回调 你写给别人用的函数，就是回调 request.onreadystatechange就是我写给浏览器调用的 意思就是你(浏览器)回头调用一下这个函数  在中文里，’回头’ 也有 &amp;lsquo;将来&amp;rsquo; 的意思, 如 ‘我回头请你吃饭’
   回调举例 把函数 1 给另一个函数 2 function f1() {} function f2(fn) { fn(); } f2(f1);  分析  Q: 我调用f1没有？A: 没有调用 Q: 我把f1传给f2(别人)了没有？A: 传了 Q: f2调用f1了没有？A: f2调用了f1 Q: 那么，f1是不是我写给f2调用的函数？A: 是   所以，f1是回调</description>
    </item>
    
    <item>
      <title>AJAX的原理和加载JSON</title>
      <link>https://zhixiukang.com/posts/ajax-principles-and-load-json-with-ajax/</link>
      <pubDate>Wed, 11 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/ajax-principles-and-load-json-with-ajax/</guid>
      <description>AJAX(Async JavaScript And XML) → 用 JS 发请求和收响应
 让我们通过使用 AJAX 来加载 CSS、JavaScript、HTML、XML 和 JSON，学会 AJAX 的原理和用法。
 示例代码
 背景 AJAX 是浏览器上的功能  浏览器可以发请求，收响应 浏览器在 window 上加了一个XMLHttpRequest函数 用这个构造函数(类)可以构造出一个对象 JS 通过它实现发请求，收响应  小工具:node-dev
   准备一个服务器  使用server.js作为我们的服务器 用node server.js 8888启动 添加index.html/main.js两个路由:  if (path === &amp;quot;/index.html&amp;quot;) { response.statusCode = 200; response.setHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/html;charset=utf-8&amp;quot;); response.write(` &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;ajax&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;AJAX demo&amp;lt;/h1&amp;gt; &amp;lt;script src=&amp;quot;/main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; `); response.end(); } else if (path === &amp;quot;/main.</description>
    </item>
    
    <item>
      <title>jQuery 中的设计模式和思想</title>
      <link>https://zhixiukang.com/posts/design-patterns-in-jquery/</link>
      <pubDate>Mon, 09 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/design-patterns-in-jquery/</guid>
      <description>参考资料:
jQuery 都过时了，那我还学它干嘛? - 方应杭
jQuery 设计思想 - 阮一峰的网络日志
jQuery Fundamentals - Bocoup
 特殊函数 jQuery window.jQuery(); // 提供的全局函数   jQuery(选择器)用来获取对应的元素 但它却不返回这些元素 相反，它返回一个 jQuery 构造出来的对象 这个对象可以操作对应的元素   jQuery 是构造函数吗?
是: 因为 jQuery 函数确实构造出了一个对象.
不是: 因为不需要new jQuery()就能构造一个对象.
结论: jQuery 是一个不需要加 new 的构造函数
  嫌 jQuery 太长？
还记得 bash alias 吗，添加一个别名即可: window.$ = window.jQuery
 命名风格  下面的代码令人误解:  const div = $(‘div#test&#39;)   我们会误以为 div 是一个 DOM，实际上 div 是 jQuery 构造的 api 对象，怎么避免这种误解呢？</description>
    </item>
    
    <item>
      <title>Bogleheads的投资哲学</title>
      <link>https://zhixiukang.com/explore/bogleheads-investment-philosophy/</link>
      <pubDate>Sun, 08 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/explore/bogleheads-investment-philosophy/</guid>
      <description>本文参考来源: Bogleheads® investment philosophy - Bogleheads
  本文参考视频: Ten Rules About Investing For Beginners - FinancingLife
  R.I.P. Jack Bogle 🙏
 指定可行的计划(Develop a workable plan)  如果你不知道要去的地方，那么你将到达其他地方。
  避免坏账，如果有，优先偿还。 开始为紧急资金储蓄。建立一个 应急基金 。不要跳过这一步！   既定的应急基金可以在发生不可预见的事件时为个人提供所需的资金。
 定期投资(Invest early and often)  对于应为哪个帐户存入资金以及以什么顺序存有特定的指导原则 。但请始终记住，首先需要省钱。开始这一终生过程时，定期储蓄比选择投资更为重要。
  收入的百分之二十是一个很好的基准数字。 提早开始定期储蓄计划之所以重要，是因为可以在更长的时间内扩大投资收益的复合。(The power of compound) 节省金钱的最好方法是从薪水中自动扣除,这对建立和加强合理的消费习惯大有帮助。   401(k)
IRA .(这里面也有 IRA 和 401(k)的比较)
 不要承受过高或过低风险(Never bear too much or too little risk)  格雷厄姆的永恒建议: 我们建议，作为基本指导原则，投资者的股票占比不得少于 25％或超过 75％，其结果是债券的反比范围为 75％至 25％。这意味着在两种主要投资媒介之间，标准划分应等于 50-50。</description>
    </item>
    
    <item>
      <title>DOM编程和操作跨线程</title>
      <link>https://zhixiukang.com/posts/dom-programming/</link>
      <pubDate>Sat, 07 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/dom-programming/</guid>
      <description>获取任意元素 有很多 API window.idxxx; // 或者直接idxxx document.getElementById(&amp;quot;idxxx&amp;quot;); document.getElementsByTagName(&amp;quot;div&amp;quot;)[0]; document.getElementsByClassName(&amp;quot;red&amp;quot;)[0]; document.querySelector(&amp;quot;#idxxx&amp;quot;); // 记得加# document.querySelectorAll(&amp;quot;.red&amp;quot;)[0];  用哪一个  工作中用querySelector和querySelectorAll
例子:document.querySelectorAll(&#39;div&amp;gt;span:nth-child(2)&#39;)
  做 demo 直接用idxxx，千万别让人发现 hhh
  要兼容 IE 的可怜虫才用getElement(s)ByXXX
 获取特定元素 获取 html 元素 document.documentElement;  获取 head 元素 document.head;  获取 body 元素 document.body;  获取窗口  窗口不是元素
 window;  获取所有元素 document.all; // false   这个 document.all 是个奇葩，第 6 个 falsy 值。原因是过去用来判断是否是 IE 浏览器。
 元素的 6 层原型链 抓一只 div 对象来看看 console.</description>
    </item>
    
    <item>
      <title>JS总结</title>
      <link>https://zhixiukang.com/posts/js-conclusion/</link>
      <pubDate>Thu, 05 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/js-conclusion/</guid>
      <description>知识点 基本概念 内存、变量、数据类型、对象
控制语句  if…else&amp;hellip; for…  对象  原型、原型链 对象分类 new一个新对象 构造函数 this的隐式传递和显式传递  难点  JS三座大山
  原型 this AJAX  最重要的知识 JS公式 对象.__proto__===其构造函数.prototype   JS唯一公式，如果不会就套公式
 根公理 Object.prototype是所有对象的(直接或间接)原型   加了一个直接或间接，所谓公理就是规定好的
 函数公理 所有函数都是由Function构造的   任何函数.__proto__===Function.prototype
任意函数有Object/Array/Function
 拨乱反正 乱一 XXX的原型  {name:&#39;frank&#39;}的原型   Object.prototype
  [1, 2, 3]的原型   Array.prototype
  Object的原型   Function.prototype
 解读  Object的原型是Object.</description>
    </item>
    
    <item>
      <title>面试中的JS运算符</title>
      <link>https://zhixiukang.com/posts/js-operators/</link>
      <pubDate>Tue, 03 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/js-operators/</guid>
      <description>算数运算符  ＋－* / 余数%  //JS的错误 -1%7 //-1 而不是 6   指数 x**3 自增自减  x++ //这个表达式的值为x，最后返回x+1 ++x //这个表达式的值为x+1，最后返回x+1 x-- //这个表达式的值为x，最后返回x-1 --x //这个表达式的值为x-1，最后返回x-1   尽量少用自增自减
  求值运算符  // 可以将任何值转为数值（与Number函数的作用相同） +(-1)// -1 +true // 1 +[] // 0 +{} // NaN   负数运算符  // 同样具有将一个值转为数值的功能，只不过得到的值正负相反 -(-1) // 1 -true // -1 -[] // -0 -{} // NaN   JS的一个糟粕  1 + &#39;2&#39; //&amp;quot;12&amp;quot; 2 - &#39;1&#39; // 1 // +号运算符默认把所有运算子变成字符串然后运算 // -号运算符默认把所有运算子变成数值然后运算  比较运算符  JS三位一体  意思是:</description>
    </item>
    
    <item>
      <title>JS函数和你不知道的this</title>
      <link>https://zhixiukang.com/posts/js-funtion-and-this/</link>
      <pubDate>Sun, 01 Mar 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/js-funtion-and-this/</guid>
      <description>四种方式定义函数 具名函数 function 函数名(形式参数1, 形式参数2) { 语句 return 返回值 }  匿名函数  上面的具名函数，去掉函数名就是匿名函数 let a = function(x, y) {return x+y} 也叫函数表达式  箭头函数 let f1 = x =&amp;gt; x*x let f2 = (x, y) =&amp;gt; x+y // 圆括号不能省 let f3 = (x, y) =&amp;gt; {return x+y} //花括号不能省 let f4 = (x, y) =&amp;gt; ({name:x, age: y})   直接返回对象会出错，需要加个圆括号
 构造函数  let f = new Function(‘x’, ‘y’, ‘return x+y’) 所有函数都是Function构造出来的 包括Object、Array、Function也是   基本没人用，但是能让你知道函数是谁构造的</description>
    </item>
    
    <item>
      <title>JS数组的增删改查和数组变换</title>
      <link>https://zhixiukang.com/posts/js-array/</link>
      <pubDate>Thu, 27 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/js-array/</guid>
      <description>JS 的数组不是典型数组 典型的数组  元素的数据类型相同 使用连续的内存存储 通过数字下标获取元素  但 JS 的数组不这样  元素的数据类型可以不同 内存不一定是连续的(对象是随机存储的) 不能通过数字下标，而是通过字符串下标 这意味着数组可以有任何 key  let arr = [1, 2, 3] arr[‘xxx&#39;] = 1  创建一个数组 新建 let arr = [1, 2, 3]; let arr = new Array(1, 2, 3); let arr = new Array(3);  转化 let arr = &#39;1, 2, 3&#39;.split(‘,’) let arr = &#39;123&#39;.split(‘’) Array.from(&#39;123&#39;)  伪数组 let divList = document.querySelector(‘div’) let divArray = Array.</description>
    </item>
    
    <item>
      <title>JS对象分类、原型和共用属性的关系、对象的ES6写法</title>
      <link>https://zhixiukang.com/posts/js-object-and-prototype-with-public-attributes/</link>
      <pubDate>Tue, 25 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/js-object-and-prototype-with-public-attributes/</guid>
      <description>延伸阅读
你可以不会 class，但是一定要学会 prototype
JS 的 new 到底是干什么的？
JS 中 proto 和 prototype 存在的意义是什么？
ES6 所有新特性
 构造函数 函数和原型结合 function createSquare(width) { let obj = Object.create(createSquare.squarePrototype) obj.width = width return obj } createSquare.squarePrototype = { getArea() { return this.width * this.width	}, getLength() { return this.width * 4 }, constructor: createSquare } let square = createSquare(5)  简化为：
function Square(width) { this.width = width } Square.prototype.getArea = function() { return this.</description>
    </item>
    
    <item>
      <title>JS对象的增删改查</title>
      <link>https://zhixiukang.com/posts/create-retrieve-update-delete-of-js-object/</link>
      <pubDate>Sun, 23 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/create-retrieve-update-delete-of-js-object/</guid>
      <description>七种数据类型？
number string bool symbol
null undefined
object
  五个 falsy 值？
null undefined
0 NaN
‘’
 对象的语法 定义  无序的数据集合 键值对的集合  写法 let obj = {&#39;name&#39;: &#39;frank’, ‘age’: 18} let obj = new Object({‘name’: ‘frank’}) console.log({&#39;name&#39;: ‘frank’, ‘age’: 18})  细节  键名是字符串，不是标识符，可以包含任意字符 引号可省略，省略之后就只能写标识符 就算引号省略了，键名也还是字符串  Object.keys(object)可以得到 object 的所有 key
   变量作属性名 如何用变量做属性名 let p1 = &#39;name&#39; // 这样写，属性名为&#39;p1&#39; let obj = {p1: &#39;frank’} // 这样写，属性名为&#39;name&#39; let obj = {[p1]: &#39;frank’}  对比  不加[]的属性名会自动变成字符串 加了[]的则会被当做变量求值 值如果不是字符串，则会自动变成字符串  对象的隐藏属性  JS 中每一个对象都有一个隐藏属性 这个隐藏属性存储着其共有属性组成的对象的地址 这个公有属性组成的对象叫做原型 也就是说，隐藏属性储存着原型的地址  var obj = {}; obj.</description>
    </item>
    
    <item>
      <title>字符编码、JS数据类型、变量声明、类型转换</title>
      <link>https://zhixiukang.com/posts/encoding-js-data-type-variable-declaration-typecasting/</link>
      <pubDate>Thu, 20 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/encoding-js-data-type-variable-declaration-typecasting/</guid>
      <description>推荐阅读: 我用了两个月的时间才理解 let - 知乎
  字符编码笔记：ASCII，Unicode 和 UTF-8 - 阮一峰的网络日志
 JS 中的数据类型 7 种  数字 number 字符串 string 布尔 bool 符号 symbol 空 undefined 空 null 对象 object  总结: 四基两空一对象
   以下不是数据类型  数组、函数、日期 它们都属于 object  数字 number(64 位浮点数) 写法  整数写法: 1 小数写法: 0.1 科学计数法: 1.23e4 八进制写法: 0123 或 00123 或 0o123 十六进制写法: 0x3F 或 0X3F 二进制写法: 0b11 或 0B11  特殊值  正 0 和负 0: 都等于 0，要严谨 无穷大: Infinity、+Infinity、-Infinity 无法表示的数字: NaN(Not a Number), 但它是一个数字  NaN === NaN; false;  64 位浮点数 JS 数字的存储形式:</description>
    </item>
    
    <item>
      <title>JS语法</title>
      <link>https://zhixiukang.com/posts/js-grammar/</link>
      <pubDate>Tue, 18 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/js-grammar/</guid>
      <description>JS 语法  参考资料: JavaScript 的基本语法 - JavaScript 教程 - 网道
 JS 版本 历史版本  ES3, IE 6 支持，总体评价: 垃圾 ES5, 总体评价: 还是垃圾 ES6, 大部分浏览器支持,总体评价:一半垃圾一半好 ES2019 与 ES6 差别不大  为什么说 ES6 一半垃圾  因为 ES 不能删除以前的特性，要兼容旧网站 也就是说以前能运行的网站，以后都要能运行 对于 Python3 你就能知道兼容的好处: 稳定   JS 之父对 JS 的早期评价(ES6 前): 它的优秀之处并非原创，它的原创之处并不优秀。
  取其精华，去其糟粕。是我们对待 JS 的态度。
 表达式、语句、标识符 表达式与语句 表达式  1+2 表达式的值为 3 add(1,2)表达式的值为函数的返回值 console.log 表达式的值为函数本身  Q: console.log(3)表达式的值为多少？</description>
    </item>
    
    <item>
      <title>内存图和 JS 世界</title>
      <link>https://zhixiukang.com/posts/memory-map-and-js-world/</link>
      <pubDate>Sat, 15 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/memory-map-and-js-world/</guid>
      <description>JS 小知识:
JavaScript 的历史
Javascript 诞生记
Javascript 的 10 个设计缺陷
 操作系统常识 一切都运行在内存里 开机  操作系统在 C 盘里(macOS 的在根目录下多个目录里) 当你按下开机键，主板通电，开始读取固件 固件就是固定在主板上的存储设备，里面有开机程序 开机程序会将文件里的操作系统加载到内存中运行  操作系统(以 Linux 为例)  首先加载操作系统内核 然后启动初始化进程，编号为 1，每个进程都有编号 启动系统服务: 文件、安全、联网 等待用户登录: 输入密码登录/ssh 登录 登录后，运行 shell，用户就可以和操作系统对话了 bash 是一种 shell，图形化界面可认为是一种 shell  打开浏览器 chrome.exe  你双击 Chrome 图标，就会运行 chrome.exe 文件 开启 Chrome 进程，作为主进程 主进程会开启一些辅助进程，如网络服务、GPU 加速 你每新建一个网页，就有可能会开启一个子进程  浏览器的功能   发起请求，下载 HTML，解析 HTML，下载 CSS，解析 CSS，渲染界面，下载 JS，解析 JS，执行 JS 等</description>
    </item>
    
    <item>
      <title>请求和响应 &amp; Node.js Server</title>
      <link>https://zhixiukang.com/posts/request-response-and-nodejs-server/</link>
      <pubDate>Wed, 12 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/request-response-and-nodejs-server/</guid>
      <description>请求与响应模型  帮你发请求的工具叫做User-Agent
 如何做出一个响应  Node.js 有一个 http 模块可以做到  初始代码
   注意事项  这些代码就是服务器代码，一般放在服务器上 path 是不带查询参数的路径 /x query 是查询参数的对象形式{a:’1’} queryString 是查询参数的字符串形式?a=1 pathWithQuery 是带查询参数的路径，一般不用 request 是请求对象 response 是响应对象  代码逻辑  每次收到请求都会把中间的代码执行一遍 用 if else 判断路径，并返回响应 如果是已知路径，一律返回 200 如果是未知路径，一律返回 404 Content-Type 表示内容的类型/语法 response.write()可以填写返回的内容 response.end()表示响应可以发给用户了   URL 里的后缀没有用, /y.css 不一定是 CSS 内容
  Content-Type 才是决定文件类型的关键
 HTTP 基础概念之请求  请求动词 路径加查询参数 协议名/版本 Host: 域名或 IP Accept: text/html Content-Type: 请求体的格式 回车 请求体(也就是上传内容)  细节  三部分: 请求行、请求头、请求体 请求动词有 GET/POST/PUT/PATCH/DELETE 等   GET 用来获取内容，POST 用来上传内容</description>
    </item>
    
    <item>
      <title>IP、端口、域名、URL</title>
      <link>https://zhixiukang.com/posts/ip-port-domain-url/</link>
      <pubDate>Mon, 10 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/ip-port-domain-url/</guid>
      <description>Tim Berners-Lee 发明了 WWW
WWW = URL + HTTP + HTML
 IP 什么是 IP Internet Protocol 主要约定了两件事:
 如何定位一台设备 如何封装数据报文，以跟其他设备交流  IP 分为内网和外网  Difference between External and Local IP Addresses
 几个特殊的 IP  127.0.0.1 表示自己 localhost 通过 hosts 指定为自己 0.0.0.0 不表示任何设备  hosts 文件在哪？
在 Windows 系统中，hosts 位于 C:\Windows\System32\drivers\etc\hosts 。
在 macOS / Linux 系统中，hosts 位于 /etc/hosts
可以给其他的 ip 起别名，方便访问。
   端口 端口号 一台机器可以提供很多服务，每个服务一个号码，这个号码就叫端口号 port。</description>
    </item>
    
    <item>
      <title>CSS动画中的transition过渡和animation</title>
      <link>https://zhixiukang.com/posts/transition-and-animation/</link>
      <pubDate>Fri, 07 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/transition-and-animation/</guid>
      <description>transition 过渡 完整文档: transition | MDN
作用  补充中间帧  语法:  transition: 属性名 时长 过渡方式 延迟时间 transition: left 200ms linear 可以用逗号分隔两个不同属性 transition: left 200ms, top 400ms 可以用 all 代表所有属性 transition: all 200ms 过渡方式有:  &amp;lt;timing-function&amp;gt; = linear | &amp;lt;cubic-bezier-timing-function&amp;gt; | &amp;lt;step-timing-function&amp;gt; where &amp;lt;cubic-bezier-timing-function&amp;gt; = ease | ease-in | ease-out | ease-in-out | cubic-bezier(&amp;lt;number&amp;gt;, &amp;lt;number&amp;gt;, &amp;lt;number&amp;gt;, &amp;lt;number&amp;gt;) &amp;lt;step-timing-function&amp;gt; = step-start | step-end | steps(&amp;lt;integer&amp;gt;[, &amp;lt;step-position&amp;gt;]?)   的具体含义要靠数学知识
 注意  并不是所有属性都能过渡 display: none=&amp;gt;block没法过渡 一般改成visibility:hidden=&amp;gt;visible background 颜色可以过渡吗？可以。 opacity 透明度可以过渡吗？可以。  过渡必须要有起始。</description>
    </item>
    
    <item>
      <title>CSS动画中的transform</title>
      <link>https://zhixiukang.com/posts/transform/</link>
      <pubDate>Wed, 05 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/transform/</guid>
      <description>完整文档: transform - CSS（层叠样式表） | MDN
四个常用功能  位移 translate 缩放 scale 旋转 rotate 倾斜 skew  经验:
一般都需要配合 transition 过渡
inline 元素不支持 transform,需要先变成 block
   transform 之 translate 常用写法 &amp;lt;translateX()&amp;gt; = translateX( &amp;lt;length-percentage&amp;gt; ) &amp;lt;translateY()&amp;gt; = translateY( &amp;lt;length-percentage&amp;gt; ) &amp;lt;translateZ()&amp;gt; = translateZ( &amp;lt;length&amp;gt; )且父容器perspective &amp;lt;translate()&amp;gt; = translate( &amp;lt;length-percentage&amp;gt; , &amp;lt;length-percentage&amp;gt; ) &amp;lt;translate3d()&amp;gt; = translate3d( &amp;lt;length-percentage&amp;gt; , &amp;lt;length-percentage&amp;gt; , &amp;lt;length&amp;gt; )   示例代码
 经验  要学会看懂 MDN 的语法示例 translate(-50%, -50%)可做绝对定位元素的居中  #demo { left: 50%; right: 50%; transform: translate(-50%, -50%); }  transform 之 scale 常用写法 &amp;lt;scaleX()&amp;gt; = scaleX( &amp;lt;number&amp;gt; ) &amp;lt;scaleY()&amp;gt; = scaleY( &amp;lt;number&amp;gt; ) &amp;lt;scale()&amp;gt; = scale( &amp;lt;number&amp;gt; , &amp;lt;number&amp;gt;?</description>
    </item>
    
    <item>
      <title>CSS动画的原理和浏览器渲染原理</title>
      <link>https://zhixiukang.com/posts/browser-rendering/</link>
      <pubDate>Sun, 02 Feb 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/browser-rendering/</guid>
      <description>动画的原理 一个最简单的例子 将 div 从左往右移动 点我看例子
原理  每过一段时间(用 setInterval 做到) 将 div 移动一小段距离 直到移动到目标地点  注意性能  绿色表示重新绘制(repaint)了  Console→Rendering→ 勾选 Paint flashing
  CSS 渲染过程依次包含布局、绘制、合成 其中布局和绘制有可能被省略  前端高手不用 left 做动画 用 transform(变形)  示例代码
 原理 - transform: translateX(0=&amp;gt;300px) - 直接修改会被合成，需要等一会修改 - transition过渡属性可以自动脑补中间帧  注意性能  并没有 repaint(重新绘制) 比改 left 性能好  浏览器渲染原理 参考文章  渲染树构建、布局及绘制 渲染性能 使用 transform 来实现动画 查看 CSS 个属性触发什么: CSS Triggers  Q: Blink, Gecko, WebKit, EdgeHTML 是啥？</description>
    </item>
    
    <item>
      <title>CSS定位</title>
      <link>https://zhixiukang.com/posts/css-positioning/</link>
      <pubDate>Fri, 31 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/css-positioning/</guid>
      <description>布局和定位有啥区别?
区别大了，布局是屏幕平面上的，定位是垂直于屏幕的
还得从文档流和盒模型说起
复习一下盒模型
 一个 div 的分层  文字在最上层，border 在第二层，background 在第三层。
  Q: 浮动元素和块级子元素是什么意思呢？
A: 这里有一个例子
  Q: 浮动元素脱离文档流是什么意思?
A: 其实就是浮起来了一点点
 新属性 - position static默认值，待在文档流里 relative相对定位，升起来，但不脱离文档流 .demo { position: relative; top: 10px; left: 10px; }   站的位置一样，但是显示的地方有一定的偏移量。
 使用场景  用于做位移(很少用) 用于给 absolute 元素做爸爸  爸爸用 relative，儿子用 absolute
   配合 z-index  z-index:auto默认值，不创建新层叠上下文 z-index: 0/ 1/ 2 z-index: -1/ -2  默认为z-index: auto;，auto其实等于 0, 但是你不可以写z-index: 0;。</description>
    </item>
    
    <item>
      <title>Grid布局(Grid)</title>
      <link>https://zhixiukang.com/posts/grid-layout/</link>
      <pubDate>Tue, 28 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/grid-layout/</guid>
      <description>完整参考资料:A Complete Guide to Grid | CSS-Tricks
二维布局用 Grid  一维布局用 Flex(要么横着排或者竖着排)
 Grid Container 的属性 成为 container .container { display: grid | inline-grid; }  行和列 .container { grid-template-columns: &amp;lt;track-size&amp;gt; … | &amp;lt;line-name&amp;gt; &amp;lt;track-size&amp;gt; …; grid-template-rows: &amp;lt;track-size&amp;gt; … | &amp;lt;line-name&amp;gt; &amp;lt;track-size&amp;gt; …; }  举个例子:
.container { grid-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto; }   当我们声明几行几列之后，就会有一个虚的线把它分隔。你可以在任何地方去放一个div。比如你可以在第一个块那里上一个div，你也可以在 1 到 5 那里放一个div。可以通过指定row是从那一条线到哪一条线，column是从哪一条线到哪一条线，非常精准。
 你还可以给每条线取名字(一般不取这么复杂的名字，我们直接用数字就好了):
.container { grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]; grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line]; }  取名有啥用？利用#item可以设置范围:</description>
    </item>
    
    <item>
      <title>Flex 布局(Flexbox)</title>
      <link>https://zhixiukang.com/posts/flexbox/</link>
      <pubDate>Sat, 25 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/flexbox/</guid>
      <description>完整参考资料: A Complete Guide to Flexbox | CSS-Tricks
容器 container flex container 有哪些样式(属性) 让一个元素变成 flex 容器 .container { display: flex; /* or inline-flex */ }   一个是 flex，一个是行内的 flex
 改变 items 流动方向(主轴) .container { flex-direction: row | row-reverse | column | column-reverse; }   可以通过 flex-direction 控制流动方向。默认是 row(从左到右)。
  控制的方向就叫做主轴，比如说你控制的是从左往右，那么主轴的方向就是从左往右。你控制的是从右往左，那么主轴的方向就是从右往左。你控制的什么方向，主轴就是什么方向。
 改变折行 在我们讲文档流的时候说过，如果你是从左往右排，到了底部你如果空间不够你回折行的对不对。但是如果你不做特殊的判断，这个弹性盒一行有多少空间就给你挤多少空间，他会一直挤下去。那么如何解决这个问题？答案是你可以控制是否要换行。
.container { flex-wrap: nowrap | wrap | wrap-reverse; }   默认是 no wrap(不折行)，wrap(折行)。一般我们都是 wrap 的。wrap-reverse(从下面往上折)。</description>
    </item>
    
    <item>
      <title>Float 布局(Floats)</title>
      <link>https://zhixiukang.com/posts/floats/</link>
      <pubDate>Wed, 22 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/floats/</guid>
      <description>步骤  在子元素上加float:left和width :::在父元素上加.clearfix:::，这个超级重要。  .clearfix:after { content: &amp;quot;&amp;quot;; display: block; clear: both; }  代码在这里
经验  有经验者会留一些空间或者最后一个不设width（最后一个不设宽度，会让它自己拓展，当然了，可以给一个最大宽度。） 如果用 float 布局，不需要做响应式，因为手机上没有 IE，而这个布局是专门为 IE 准备的。 IE6/7 存在双倍 margin bug，解决办法有两个: 1. 将错就错，针对 IE6 或者 IE7 把 margin 减半: margin-left:10px _margin-left:5px 这样一来，普通浏览器就是 10px, 但是 IE 是 5*2=10px 还是 10px。 3. 神来一笔，再加一个display:inline-block  实践 不同布局  用 float 做两栏布局(如顶部条) 用 float 做三栏布局(如内容区) 用 float 做四栏布局(如导航) 点我看看 用 float 做平均布局(如产品展示区) 曾经淘宝的前端发明了双飞翼布局，不要学，已过时  float 实例代码</description>
    </item>
    
    <item>
      <title>CSS布局和一图流</title>
      <link>https://zhixiukang.com/posts/css-layout/</link>
      <pubDate>Mon, 20 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/css-layout/</guid>
      <description>布局是什么 把页面分成一块一块，按左中右、上中下等排列。
布局分类 两种  固定宽度布局，一般宽度为 960/1000/1024px  比如淘宝就是固定宽度布局，到了一定宽度你再怎么拉，他还是这个宽度。
  不固定宽度布局，主要靠文档流的原理来布局  一般在手机上用
   还记得吗  文档流本来就是自适应的，不需要加额外的样式  不用加width这种属性，页面本身就是响应式的。
   第三种布局  响应式布局 意思就是 PC 上固定宽度，手机上不固定宽度  其实就是前两种布局的合并，但为什么叫第三种布局，起了个新名字？CSS 就这个毛病。
  也就是一种混合布局  布局的两种思路 从大到小  先定下大局 然后完善每个部分的小布局  从小到大  先完成小布局 然后组合成大布局  两种均可  新人推荐用第二种，因为小的简单 老手一般用第一种，因为熟练有大局观  一图流  为什么 grid 布局不用负 margin？ 因为 grid 布局可以通过grid-gap来解决间隙问题。
  草图软件工具推荐
Balsamiq for Desktop | Balsamiq</description>
    </item>
    
    <item>
      <title>盒模型</title>
      <link>https://zhixiukang.com/posts/box-model/</link>
      <pubDate>Fri, 17 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/box-model/</guid>
      <description>概念 盒模型有四个概念，从外到内分别是外边距(margin)、border、内边距(padding)和 content。如果是 content box，那么只包含最里面的 content。如果是 border box，那么只包含 content、padding 和 border(如果是 border box，那么除了 margin 都包含)。
 请说一下 css 的盒模型?  css 盒模型分两种，一种是 content-box,一种是 border-box，content-box 的宽度只包含 content，border-box 的宽度包含到 border(border, padding and content)。
   两种盒模型 分别是  content-box 内容盒-内容就是盒子的边界。 border-box 边框盒-边框才是盒子的边界。  公式  content-box width = 内容宽度 border-box width = 内容宽度 + padding + border  哪个好用  border-box好用 同时指定padding、width、border就知道为什么了 如果没有指定padding和border，看不出来这俩的区别。  margin合并 哪些情况会合并  父子 margin 合并 上面边距有可能重叠。 兄弟 margin 合并 其实 css 这么设计是有道理的:   如何阻止合并  父子合并用 padding/border 挡住  padding-top: 1px; border-top: 1px solid green;   父子合并用 overflow:hidden 挡住 父子合并用 display:flex，不知道为什么 兄弟合并是符合预期的 兄弟合并可以用 inline-block 消除 总之要一条一条死记 而且 CSS 的属性逐年增多，每年都有可能有新的  基本单位 长度单位  px 像素 em 相对于自身 font-size 的倍数 百分数 整数 rem:等你把 em 滚瓜烂熟了再问 rem vw 和 vh 其他长度单位都用得很少，不用了解  颜色  十六进制#FF6600或者#F60(两个两个一对的可以缩写) RGBA 颜色 rgb(0,0,0)或者 rgba(0,0,0,1) hsl 颜色 hsl(360,100%,100%) (0 度正红色-360, 鲜艳程度, 亮度)  做个彩虹练习一下 点我后自己试试吧</description>
    </item>
    
    <item>
      <title>文档流</title>
      <link>https://zhixiukang.com/posts/normal-flow/</link>
      <pubDate>Wed, 15 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/normal-flow/</guid>
      <description>基本概念 文档流是指文档中元素流动的方向。
哪些是 inline 元素，哪些是 block 元素
文档流 | MDN
要理解几个重要的概念  文档流 Normal Flow span元素从左到右， div元素从上到下。 块、内联、内联块 margin 合并 两种盒模型(border-box 更符合人类思维)  inline 元素里不要写 block 元素。不知道会遇到什么 bug。
style width:100%就不要这么用。
   流动方向  inline元素从左到右，到达最右边才会换行 block元素从上到下，每一个都另起一行 inline-block也是从左到右,但是到达最后的时候，不会把自己分成两块。  宽度  inline宽度为内部inline元素的和，不能用width指定 block默认自动计算宽度，可用width指定 inline-block结合前两者特点，可用width  高度  inline高度由line-height间接确定，跟height无关 block高度由内部文档流元素决定，可以设height inline-block跟block类似，可以设置height  overflow 溢出 当内容大于容器  当内容的宽度或高度大于容器的，会溢出 可用overflow来设置是否显示滚动条 auto是灵活设置(常用) scroll是永远显示 hidden是直接隐藏溢出部分(常用) visible是直接显示溢出部分(常用) overflow可以分为overflow-x和overflow-y(不好用)  脱离文档流 回忆一下  block 高度由内部文档流元素决定，可以设 height。  这句话的意思是说，有些元素可以不在文档流中。</description>
    </item>
    
    <item>
      <title>HTML重难点</title>
      <link>https://zhixiukang.com/posts/html-key-parts/</link>
      <pubDate>Sat, 11 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/html-key-parts/</guid>
      <description>a 标签 属性  href hyper reference.  新建终端，执行：
yarn global add http-server
在本地运行，不保留缓存：
http-server -c-1或者
http-server . -c-1
使用http-server预览html,不要双击打开。
可以使用hs -c-1缩写版本，快一点。
    还可以使用parcel：
yarn global add parcel
parcel #filename.suffix
  target  &amp;lt;!— 可以指定在哪个地方打开超链接 (在空白页打开)—&amp;gt; &amp;lt;a href=“https://google.com” target=“_blank”&amp;gt;hyper link&amp;lt;/a&amp;gt;   download  &amp;lt;!-- 下载这个网页，基本不能用—&amp;gt; &amp;lt;a href=“https://google.com” download&amp;gt;hyper link&amp;lt;/a&amp;gt;   rel=noopener 防止一个 js 的 bug。  作用  跳转外部页面 跳转内部锚点 跳转到邮箱或电话等  a的href的取值  网址  https://google.</description>
    </item>
    
    <item>
      <title>[词汇及句子]拥有</title>
      <link>https://zhixiukang.com/explore/possess/</link>
      <pubDate>Fri, 10 Jan 2020 20:34:38 -0800</pubDate>
      
      <guid>https://zhixiukang.com/explore/possess/</guid>
      <description>本單元主要學習與表示“有”有關的句型語法。
1. &amp;ldquo;A ＋은/는/＋ B+이/가＋있습니다&amp;rdquo; = A 有 B &amp;ldquo;있습니다(issseubnida)&amp;quot;：尊敬詞尾，“有”。
학생은 책이 있습니다.
學生有書。
저는 키가 있습니다.
我有鑰匙。
2. &amp;ldquo;A ＋은/는＋ B ＋이/가+없습니다&amp;rdquo; = A 沒有 B &amp;ldquo;없습니다(eobs-seubnida)&amp;rdquo; ：尊敬詞尾，是“있습니다”的否定形式，“沒有”。
저는 신문이 없습니다.
我沒有報紙。
그 남자는 아이가 없습니다.
那個男人沒有孩子。
3. &amp;ldquo;A ＋은/는/＋ B+이/가＋있습니까?&amp;rdquo; = A 有 B 嗎? &amp;ldquo;있습니까(issseubnikka)&amp;rdquo; ：尊敬詞尾，是“있다”的疑問形式。
그 여자는 아이가 있습니까?
那個女人有孩子嗎?
그 선생님은 학생이 있습니까?
那個老師有學生嗎？ </description>
    </item>
    
    <item>
      <title>[词汇及句子]房间名称，家具，睡了吗？明天见~</title>
      <link>https://zhixiukang.com/explore/furniture-rooms-greeting/</link>
      <pubDate>Thu, 09 Jan 2020 20:34:38 -0800</pubDate>
      
      <guid>https://zhixiukang.com/explore/furniture-rooms-greeting/</guid>
      <description></description>
    </item>
    
    <item>
      <title>HTML标签</title>
      <link>https://zhixiukang.com/posts/html-labels/</link>
      <pubDate>Wed, 08 Jan 2020 15:21:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/html-labels/</guid>
      <description>学习工具 网道 HTML 教程
 三上:马上，枕上，厕上
 VSCode 插件推荐  Prettier 更好地格式化工具 cmd+shift+p-&amp;gt; format doc  两个工具  jsbin 饥人谷 偏好 JShint 关闭 codesandbox settings: auto save  可以将需要纠错的 URL 分享给别人
   HTML 起手式&amp;ndash;Emmet 感叹号 在空的 html 文件中，输入!+tab。
&amp;lt;!— 文档类型 --&amp;gt; &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!— html标签，可以把lang改成zh-CN —&amp;gt; &amp;lt;html lang=&amp;quot;“en”&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;!— 文件的字符编码 —&amp;gt; &amp;lt;meta charset=&amp;quot;“UTF-8”&amp;quot; /&amp;gt; &amp;lt;!— 禁用缩放 —&amp;gt; &amp;lt;meta name=“viewport” content=“width=device-width, initial-scale=1.0” /&amp;gt; &amp;lt;!— 兼容手机，告诉IE使用最新内核 —&amp;gt; &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot; /&amp;gt; &amp;lt;!</description>
    </item>
    
    <item>
      <title>韩语中的颜色</title>
      <link>https://zhixiukang.com/explore/colors/</link>
      <pubDate>Sun, 05 Jan 2020 20:17:11 -0800</pubDate>
      
      <guid>https://zhixiukang.com/explore/colors/</guid>
      <description> 白色 흰색/하얀색
黑色 검은색
黄色 노랑색/황색
红色 빨간색（红茶：홍차;红铅笔:빨간 연필）
绿色 녹색（绿茶：녹차）
蓝色 푸른색 （蔚蓝的天空 푸른 하늘）
蓝色 파란색（比푸른색淡，蓝衬衫：파란 셔츠）
深蓝 남색
粉红 분홍색/핑크색
紫色 보라색
褐色 갈색
灰色 회색 (灰色的天 회색의 하늘)
咖啡色 커피색
肉色 살색/육색
 </description>
    </item>
    
    <item>
      <title>购买域名及配置DNS和GitHub Pages</title>
      <link>https://zhixiukang.com/posts/how-to-buy-domain/</link>
      <pubDate>Sun, 05 Jan 2020 18:56:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/how-to-buy-domain/</guid>
      <description>购买域名 进入NameSilo，输入自己想要的域名并购买。
配置 DNS 和 GitHub Pages 购买后，进入右上角Manage My Domains查看自己的域名。 点击 manage DNS(小地球)
 打开 github，进入#username.github.io这个项目，进入Settings，拉到最下面, Custom Demain 填入自己的域名并 save。 这个时候回到自己的仓库，发现多了一个CNAME的文件。这个CNAME文件实际上是记录了你刚才填的域名。 回到Settings，将&#39;Enforce HTTPS&#39;取消勾选。原因：方便测试。如果你勾选了 HTTPS，那么和这个网站相关的所有网站你都要用 HTTPS，非常的不方便。建议新手不要勾选。 点击下图中的Learn more。 并进入Managing a custom domain for your GitHub Pages Site. 找到Configuring an apex domain里的4 A records。 // 这里注意每个人的ip都不一样，根据自己显示的ip来操作 18X.XXX.XXX.15X 18X.XXX.XXX.15X 18X.XXX.XXX.15X 18X.XXX.XXX.15X  回到namesilo.com中的Manage DNS页面, Add A record, 这 4 条 A record 根据上面的4 A records来填写，hostname不填, IPV4 ADDRESS为上图中的IP, TTL不用更改。
 上述过程依次完成后，Mac 用户通过:   dig noall answer #userdomain.</description>
    </item>
    
    <item>
      <title>用Hugo搭建个人博客</title>
      <link>https://zhixiukang.com/posts/how-to-install-hugo/</link>
      <pubDate>Thu, 02 Jan 2020 18:56:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/posts/how-to-install-hugo/</guid>
      <description>安装Hugo 官方教程 Hugo官方教程
Mac安装方式 brew install hugo hugo version   快速搭建博客 使用Hugo搭建博客 按照Quick Start | Hugo操作。
注意:
 当新建站点时，可以自定义参数，举个例子:  当写完每篇.md后， 可以将draft:true改为draft:false以达到发布的目的。  把 Hugo 生成的博客托管在 GitHub Pages 教程讲完了，现在问题是怎么把public这个目录挂到网上。
步骤如下:
 新建.gitignore,添加/public/ 进入public，git init,git add .,git commit -v素质三连。现在需要做的就是上传了。 怎么上传呢？需要做的就是在github上新建一个仓库。仓库名为#用户名(全部小写).github.io 然后在本地public目录下: 目标就是把public上传到单独的一个仓库。 之后git open来到我们的GitHub仓库。 接下来, 点击项目里右上角的Settings，走到最下面,  选到master。当然如果你和我一样就不用做多余操作了。
点击博客地址。当当当当，done~！  问题：   如何持续更新博客?
每次写完新的博客， 进入public目录, git add .,git commit -v,git push素质三连。
  如果不想要这个皮肤怎么办？
Complete List | Hugo Themes 你想来什么主题就来什么主题。</description>
    </item>
    
    <item>
      <title>[歌詞]BIGBANG - BAE BAE[中韩对照]</title>
      <link>https://zhixiukang.com/explore/bae-bae-lyrics/</link>
      <pubDate>Sat, 03 Aug 2019 18:56:33 -0800</pubDate>
      
      <guid>https://zhixiukang.com/explore/bae-bae-lyrics/</guid>
      <description> Bae bae
BABY BABY
지금처럼만 아름다워 줄래 넌
能不能就像現在一樣這麼的美麗
시간이 지나도
即使時間流逝
내가 설렐 수 있게
也能讓我心動不已
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zhixiukang.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhixiukang.com/about/</guid>
      <description>Email: zhixiukang@gmail.com</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zhixiukang.com/bucket-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zhixiukang.com/bucket-list/</guid>
      <description> 跳伞 打枪 国家公园中越野驾驶 坐美国的火车 坐美国的长途汽车 坐直升飞机 坐小飞机 考飞行员证 打个保龄球 穿越美国西部 穿越美国东部 考持枪证 考潜水证 韩语 HSK6 级 日语 N1 爬美国最高峰 开惊险的山路 装上雪链在雪山中行驶 学会漂移 学会冲浪 去滑雪 去漂流 学会拳击 学会柔术 尝试做个 vlog 在中国沙漠过夜 在美国沙漠过夜 坐纽约的破地铁 划橡皮艇 学会开船 钓一条大鱼 打场高尔夫 开一次室内小赛车 学会写毛笔字 去一次迪士尼  </description>
    </item>
    
  </channel>
</rss>
